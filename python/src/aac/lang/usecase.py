"""Python module for the Usecase class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional, Any
from attr import attrib, validators


@dataclass(frozen=True)
class Usecase:
    """
    A definition that represents a usecase for the system.  An example of when to use a 'usecase' is when you want to define how the system might be used in a particular instance.

    name: str - The name of the use case.
    package: Optional[str] - The package with which to associate the use case.
    description: Optional[str] - An explanatory description of the use case to include what purpose the use case serves, design ideas when fulfilling the use case, etc.
    includes: list[str] - A list of usecases that this usecase uses.  The include (uses) relationship  from usecase A to use case B indicates that an instance of the use case A  will also contain the behavior as specified by B.
    extends: list[str] - A list of use cases that this use case extends.  A relationship from an  extending use case to an extended use case that specifies when the behavior  defined in the extending use case can be inserted into the behavior defined  in the extended use case.
    participants: list[str] - A list of participants in the use case.  Generally, these would be users, other systems, etc. that are interacting with the system during the course of the use case.
    steps: list[str] - A list of steps taken in the use case. See 'Step'.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    package: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    description: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    includes: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )
    extends: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )
    participants: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )
    steps: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        package = data.pop("package", None)
        args["package"] = package

        description = data.pop("description", None)
        args["description"] = description

        includes = data.pop("includes", [])
        args["includes"] = includes

        extends = data.pop("extends", [])
        args["extends"] = extends

        participants = data.pop("participants", [])
        args["participants"] = participants

        steps = data.pop("steps", [])
        args["steps"] = steps

        return cls(**args, **data)
