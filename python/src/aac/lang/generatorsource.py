"""Python module for the GeneratorSource class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional
from attr import attrib, validators

from aac.lang.generatortemplate import GeneratorTemplate


@dataclass(frozen=True)
class GeneratorSource:
    """
    The association of an AaC type to a generator template.

    name: str - Name of the allocation.
    data_source: str - The root key of data items to be provided to the templates.
    data_content: Optional[str] - The content of the data source to be provided to the templates.  This content will be parsed as yaml and provided to the templates. Provide a 'dot-notation' representation for the content you wish to provide to the templates.  For example, if you want to provide the commands of a plugin you can provide the following content: 'plugin.commands'. If no data_content is provided, the full data_source will be provided to the template.
    templates: list[GeneratorTemplate]] - The templates to be applied to the specified model data.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    data_source: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    data_content: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    templates: list[GeneratorTemplate] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[GeneratorTemplate])
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        data_content = data.pop("data_content", None)
        args["data_content"] = data_content

        templates_data = data.pop("templates", [])
        templates = [GeneratorTemplate.from_dict(entry) for entry in templates_data]
        args["templates"] = templates

        return cls(**args, **data)
