"""Python module for the GeneratorTemplate class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional
from attr import attrib, validators

from aac.lang.overwriteoption import OverwriteOption
from aac.lang.jinjahelperfunction import JinjaHelperFunction
from aac.lang.generatoroutputtarget import GeneratorOutputTarget


@dataclass(frozen=True)
class GeneratorTemplate:
    """
    A Jinja2 template used to generate content.

    name: str - The name of the template.
    description: Optional[str] - A short description of the generator template.
    template_file: str - The path to a jinja2 template file.  The template file path provided should be relative to the AaC model referencing the template.  You must  either provide a template_file or template_contents.
    overwrite: OverwriteOption - Instructs the generator how to overwrite existing content or not.
    helper_functions: list[JinjaHelperFunction]] - A list of helper functions to be made available to the template.
    output_target: GeneratorOutputTarget - Identifies which generator output path to target.
    output_path_uses_data_source_package: Optional[bool] - Instructs the generator to insert the package name after the output path when generating files.
    output_file_prefix: Optional[str] - The prefix to use when generating the output file name.
    output_file_name: Optional[str] - Specify a file name to output.  If no name given, the default will be the plugin name.
    output_file_suffix: Optional[str] - The suffix to use when generating the output file name.
    output_file_extension: str - The file extension to use when generating the output file name.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    description: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    template_file: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    overwrite: OverwriteOption = attrib(
        init=attr.ib(), validator=validators.instance_of(OverwriteOption)
    )
    helper_functions: list[JinjaHelperFunction] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[JinjaHelperFunction])
    )
    output_target: GeneratorOutputTarget = attrib(
        init=attr.ib(), validator=validators.instance_of(GeneratorOutputTarget)
    )
    output_path_uses_data_source_package: Optional[bool] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(bool))
    )
    output_file_prefix: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    output_file_name: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    output_file_suffix: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    output_file_extension: str = attrib(
        init=attr.ib(), validator=validators.instance_of(str)
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        description = data.pop("description", None)
        args["description"] = description

        overwrite_data = data.pop("overwrite", None)
        overwrite = (
            OverwriteOption.from_dict(overwrite_data) if overwrite_data else None
        )
        args["overwrite"] = overwrite

        helper_functions_data = data.pop("helper_functions", [])
        helper_functions = [
            JinjaHelperFunction.from_dict(entry) for entry in helper_functions_data
        ]
        args["helper_functions"] = helper_functions

        output_target_data = data.pop("output_target", None)
        output_target = (
            GeneratorOutputTarget.from_dict(output_target_data)
            if output_target_data
            else None
        )
        args["output_target"] = output_target

        output_path_uses_data_source_package = data.pop(
            "output_path_uses_data_source_package", None
        )
        args[
            "output_path_uses_data_source_package"
        ] = output_path_uses_data_source_package

        output_file_prefix = data.pop("output_file_prefix", None)
        args["output_file_prefix"] = output_file_prefix

        output_file_name = data.pop("output_file_name", None)
        args["output_file_name"] = output_file_name

        output_file_suffix = data.pop("output_file_suffix", None)
        args["output_file_suffix"] = output_file_suffix

        return cls(**args, **data)
