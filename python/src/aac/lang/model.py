"""Python module for the Model class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional
from attr import attrib, validators

from aac.lang.behavior import Behavior
from aac.lang.field import Field


@dataclass(frozen=True)
class Model:
    """
    A definition that represents a system and/or component model.  An example of when to use a 'model' is when you want to define the behavior for some component of the system.

    name: str - The name of the model.
    description: Optional[str] - An explanatory description for the model including what the component/system is modeling and any other relevant information.
    components: Optional[str] - A list of models that are components of the system.
    behavior: list[Behavior]] - A list of behaviors that the system being modeled will perform.
    state: list[Field]] - A list of data items representing internal state of the modeled entity. State is visible within the model but is not visible to other models. State may be visible between multiple instances of the modeled entity to support horizontal scaling.
    requirements: list[str] - A reference to requirements relevant to the modeled item.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    description: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    components: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    behavior: list[Behavior] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[Behavior])
    )
    state: list[Field] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[Field])
    )
    requirements: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        description = data.pop("description", None)
        args["description"] = description

        components = data.pop("components", None)
        args["components"] = components

        behavior_data = data.pop("behavior", [])
        behavior = [Behavior.from_dict(entry) for entry in behavior_data]
        args["behavior"] = behavior

        state_data = data.pop("state", [])
        state = [Field.from_dict(entry) for entry in state_data]
        args["state"] = state

        requirements = data.pop("requirements", [])
        args["requirements"] = requirements

        return cls(**args, **data)
