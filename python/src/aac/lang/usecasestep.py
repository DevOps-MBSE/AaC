"""Python module for the UsecaseStep class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional, Any
from attr import attrib, validators

from aac.lang.usecasebranch import UsecaseBranch
from aac.lang.usecasebranch import UsecaseBranch


@dataclass(frozen=True)
class UsecaseStep:
    """
    Autogenerated UsecaseStep AaC schema

    name: str - The name of the step.
    source: Optional[str] - The source for the step. This should be the name of a participant - i.e. a modeled system component.
    target: Optional[str] - The target for the step. This should be the name of a participant - i.e. a modeled system component.
    action: Optional[str] - A behavior reference on the target or a subordinate use case definition.
    condition: list[UsecaseBranch]] - Used to create an "alt" in a sequence diagram.
    loop: Optional[UsecaseBranch] - Used to create a loop in a sequence diagram.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    source: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    target: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    action: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    condition: list[UsecaseBranch] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[UsecaseBranch])
    )
    loop: Optional[UsecaseBranch] = attrib(
        init=attr.ib(),
        validator=validators.optional(validators.instance_of(UsecaseBranch)),
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        source = data.pop("source", None)
        args["source"] = source

        target = data.pop("target", None)
        args["target"] = target

        action = data.pop("action", None)
        args["action"] = action

        condition_data = data.pop("condition", [])
        condition = [UsecaseBranch.from_dict(entry) for entry in condition_data]
        args["condition"] = condition

        loop_data = data.pop("loop", None)
        loop = UsecaseBranch.from_dict(loop_data) if loop_data else None
        args["loop"] = loop

        return cls(**args, **data)
