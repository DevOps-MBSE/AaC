"""Python module for the Plugin class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional, Any
from attr import attrib, validators

from aac.lang.plugincommand import PluginCommand
from aac.lang.contextconstraint import ContextConstraint
from aac.lang.schemaconstraint import SchemaConstraint
from aac.lang.primitiveconstraint import PrimitiveConstraint


@dataclass(frozen=True)
class Plugin:
    """
    A definition for an AaC plugin. Plugins can provide any extra functionality desired on top of AaC-modeled systems from document generation to code generation and everything in between.

    name: str - The name of the plugin.
    package: str - The 'dot notation' package name for the plugin.  All plugin names must be unique within an assigned type. The package will also define the directory structure produced by gen-plugin.
    description: Optional[str] - A brief description of the plugin.
    commands: list[PluginCommand]] - A list of commands that the plugin provides.
    definition_sources: list[str] - A list of AaC definition files to import for use in the plugin.
    context_constraints: list[ContextConstraint]] - A list of context constraints provided by the plugin. Context constraints evaluate all definitions in the language context.
    schema_constraints: list[SchemaConstraint]] - A list of schema constraints provided by the plugin. Schema constraints evaluate individual schema content.
    primitive_constraints: list[PrimitiveConstraint]] - A list of primitive constraints provided by the plugin. Primitive constraints evaluate individual primitive content.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    package: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    description: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    commands: list[PluginCommand] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[PluginCommand])
    )
    definition_sources: list[str] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[str])
    )
    context_constraints: list[ContextConstraint] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[ContextConstraint])
    )
    schema_constraints: list[SchemaConstraint] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[SchemaConstraint])
    )
    primitive_constraints: list[PrimitiveConstraint] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[PrimitiveConstraint])
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        description = data.pop("description", None)
        args["description"] = description

        commands_data = data.pop("commands", [])
        commands = [PluginCommand.from_dict(entry) for entry in commands_data]
        args["commands"] = commands

        definition_sources = data.pop("definition_sources", [])
        args["definition_sources"] = definition_sources

        context_constraints_data = data.pop("context_constraints", [])
        context_constraints = [
            ContextConstraint.from_dict(entry) for entry in context_constraints_data
        ]
        args["context_constraints"] = context_constraints

        schema_constraints_data = data.pop("schema_constraints", [])
        schema_constraints = [
            SchemaConstraint.from_dict(entry) for entry in schema_constraints_data
        ]
        args["schema_constraints"] = schema_constraints

        primitive_constraints_data = data.pop("primitive_constraints", [])
        primitive_constraints = [
            PrimitiveConstraint.from_dict(entry) for entry in primitive_constraints_data
        ]
        args["primitive_constraints"] = primitive_constraints

        return cls(**args, **data)
