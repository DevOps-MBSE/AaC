"""Python module for the SchemaConstraint class."""
# WARNING - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED.
# This file is auto-generated by the aac gen-plugin and may be overwritten.

from dataclasses import dataclass
import attr
from typing import Optional, Any
from attr import attrib, validators

from aac.lang.field import Field
from aac.lang.feature import Feature


@dataclass(frozen=True)
class SchemaConstraint:
    """
    The definition of a schema constraint plugin.  Schema constraints perform checks against a defined structure within a model based on it's schema definition. Defining a schema constraint allows for automted structural quality checks by running the 'aac check' command against your model.

    name: str - The name of the schema constraint rule.
    description: Optional[str] - A high level description of the schema constraint rule.
    universal: Optional[bool] - Indicates that the constraint should be applied to all schemas without explicit assignment. This is a convenience so that you don't have to directly assign the constraint to every schema. If not included or false, the constraint must be explicitly assigned to a schema.  But be aware that universal schema constraints cannot have input arguments.
    arguments: list[Field]] - List of arguments for the constraint.
    acceptance: list[Feature]] - A list of acceptance test features that describe the expected behavior of the schema constraint.
    """

    name: str = attrib(init=attr.ib(), validator=validators.instance_of(str))
    description: Optional[str] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(str))
    )
    universal: Optional[bool] = attrib(
        init=attr.ib(), validator=validators.optional(validators.instance_of(bool))
    )
    arguments: list[Field] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[Field])
    )
    acceptance: list[Feature] = attrib(
        init=attr.ib(), validator=validators.instance_of(list[Feature])
    )

    @classmethod
    def from_dict(cls, data):
        args = {}

        description = data.pop("description", None)
        args["description"] = description

        universal = data.pop("universal", None)
        args["universal"] = universal

        arguments_data = data.pop("arguments", [])
        arguments = [Field.from_dict(entry) for entry in arguments_data]
        args["arguments"] = arguments

        acceptance_data = data.pop("acceptance", [])
        acceptance = [Feature.from_dict(entry) for entry in acceptance_data]
        args["acceptance"] = acceptance

        return cls(**args, **data)
