"""AaC Plugin implementation module for the aac-plantuml plugin."""

# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from aac import parser, util
from aac.plugins.plugin_execution import PluginExecutionResult, plugin_result
from aac.validator import validation

plugin_name = "gen_plant_uml"


def puml_component(architecture_file: str) -> PluginExecutionResult:
    """
    Convert an AaC model to Plant ULM component diagram.

    Args:
        architecture_file: str: Path to a yaml file containing an AaC usecase from which to generate a Plant UML component diagram.
    """

    def generate_component_diagram():
        with validation(parser.parse_file, architecture_file) as result:
            model_types = util.get_models_by_type(result.model, "model")

            puml_lines = []
            puml_lines.append("@startuml")
            for root_model_name in _find_root_names(model_types):
                _print_component_content(model_types[root_model_name], [], puml_lines, model_types)
            puml_lines.append("@enduml")

            return "\n".join(puml_lines)

    with plugin_result(plugin_name, generate_component_diagram) as result:
        return result


def puml_sequence(architecture_file: str) -> PluginExecutionResult:
    """
    Convert an AaC usecase to Plant ULM sequence diagram.

    Args:
        architecture_file: str: Path to a yaml file containing an AaC usecase from which to generate a Plant UML sequence diagram.
    """

    def generate_sequence_diagram():
        with validation(parser.parse_file, architecture_file) as result:
            use_case_types = util.get_models_by_type(result.model, "usecase")

            puml_lines = []

            for use_case_title in _find_root_names(use_case_types):
                # start the uml
                puml_lines.append("@startuml")

                # add the title
                puml_lines.append("title {}".format(use_case_title))

                # declare participants
                participants = util.search(use_case_types[use_case_title], ["usecase", "participants"])
                for participant in participants:  # each participant is a field type
                    puml_lines.append(
                        "participant {} as {}".format(participant["type"], participant["name"])
                    )

                # process steps
                steps = util.search(use_case_types[use_case_title], ["usecase", "steps"])
                for step in steps:  # each step of a step type
                    puml_lines.append(
                        "{} -> {} : {}".format(step["source"], step["target"], step["action"])
                    )

                # end the uml
                puml_lines.append("@enduml")
                puml_lines.append("")

            return "\n".join(puml_lines)

    with plugin_result(plugin_name, generate_sequence_diagram) as result:
        return result


def puml_object(architecture_file: str) -> PluginExecutionResult:
    """
    Convert an AaC model to Plant ULM object diagram.

    Args:
        architecture_file: str: Path to a yaml file containing an AaC usecase from which to generate a Plant UML object diagram.
    """

    def generate_object_diagram():
        with validation(parser.parse_file, architecture_file) as result:
            model_types = util.get_models_by_type(result.model, "model")

            object_declarations = []
            object_compositions = {}
            for model_name in model_types.keys():
                object_declarations.append(model_name)

                for component in util.search(model_types[model_name], ["model", "components", "type"]):
                    if model_name not in object_compositions:
                        object_compositions[model_name] = set()

                    object_compositions[model_name].add(component)

            puml_lines = []
            puml_lines.append("@startuml")
            for obj in object_declarations:
                puml_lines.append("object {}".format(obj))

            for parent in object_compositions:
                for child in object_compositions[parent]:
                    puml_lines.append("{} *-- {}".format(parent, child))

            puml_lines.append("@enduml")
            return "\n".join(puml_lines)

    with plugin_result(plugin_name, generate_object_diagram) as result:
        return result


def _find_root_names(models) -> list[str]:
    model_names = list(models.keys())

    if len(model_names) == 1:
        return model_names

    # there are multiple models, so we have to look through them
    subcomponents = []  # names of subcomponent models
    for name in model_names:
        model = models[name]
        components = util.search(model, ["model", "components"])
        for component in components:
            # component is a Field type
            component_type = component["type"]
            # make sure this is a model type (not a data type)
            if component_type in model_names:
                # add the component type to the list of subs
                subcomponents.append(component_type)

    # remove the subs types from model names
    sanitized_model_names = [name for name in model_names if name not in subcomponents]
    return sanitized_model_names


def _print_component_content(root, existing, puml_lines, model_types):

    model_name = root["model"]["name"]

    # define UML interface for each input
    inputs = util.search(root, ["model", "behavior", "input"])
    for input in inputs:
        if not input["type"] in existing:
            puml_lines.append("interface {}".format(input["type"]))
            existing.append(input["type"])

    # define UML interface for each output
    outputs = util.search(root, ["model", "behavior", "output"])
    for output in outputs:
        if not output["type"] in existing:
            puml_lines.append("interface {}".format(output["type"]))
            existing.append(output["type"])

    # define UML package for each component
    components = util.search(root, ["model", "components"])

    if len(components) > 0:
        # if the model has a components, show it as a package
        puml_lines.append('package "{}" {{'.format(model_name))
        existing.append(model_name)
        for component in components:
            # component is a Field type
            component_type = component["type"]
            _print_component_content(
                model_types[component_type], existing, puml_lines, model_types
            )

        puml_lines.append("}")
    else:
        # if there are no components, show it as a class
        inputs = util.search(root, ["model", "behavior", "input"])
        for input in inputs:
            puml_lines.append("{} -> [{}] : {}".format(input["type"], model_name, input["name"]))
        outputs = util.search(root, ["model", "behavior", "output"])
        for output in outputs:
            puml_lines.append("[{}] -> {} : {}".format(model_name, output["type"], output["name"]))
