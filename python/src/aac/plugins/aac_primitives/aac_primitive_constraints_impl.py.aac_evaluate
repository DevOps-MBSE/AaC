"""The AaC AaC primitive constraints plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

# There may be some unused imports depending on the definition of the plugin...but that's ok
from aac.execute.aac_execution_result import (
    ExecutionResult,
    ExecutionStatus,
    ExecutionMessage,
)
from aac.lang.schema import Schema
from aac.lang.plugininputvalue import PluginInputValue
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from aac.io.files.aac_file import AaCFile
from aac.context.source_location import SourceLocation
from typing import Any


plugin_name = "AaC primitive constraints"


def check_bool(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check bool constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check bool constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check bool", status, messages)


def check_date(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check date constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check date constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check date", status, messages)


def check_directory(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check directory constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check directory constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check directory", status, messages)


def check_file(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check file constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check file constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check file", status, messages)


def check_string(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check string constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check string constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check string", status, messages)


def check_int(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check int constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check int constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check int", status, messages)


def check_number(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check number constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check number constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check number", status, messages)


def check_dataref(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check dataref constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check dataref constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check dataref", status, messages)


def check_typeref(
    value: str, type_declaration: str, source: AaCFile, location: SourceLocation
) -> ExecutionResult:
    """Business logic for the Check typeref constraint."""

    # TODO: rewrite the code below to implement your constraint logic
    # the checker has provided you with source and location data for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        message="The Check typeref constraint for the AaC primitive constraints plugin has not been implemented yet.",
        source=source,
        location=location,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Check typeref", status, messages)
