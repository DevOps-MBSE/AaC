"""The AaC CheckAaC plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

from typing import Callable, Any
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from aac.execute.aac_execution_result import ExecutionResult, ExecutionStatus, LanguageError
from aac.lang.primitive import Primitive
from aac.io.parser import parse

plugin_name = "CheckAaC"


def check(aac_file: str, fail_on_warn: bool, verbose: bool) -> ExecutionResult:
    """Business logic for the check command."""

    constraint_results: dict[str, ExecutionResult] = {}

    context: LanguageContext = LanguageContext()

    # collect all constraints for easy access
    all_constraints_by_name: dict[str, Callable] = {}
    for runner in context.get_plugin_runners():
        for name, callback in runner.constraint_to_callback.items():
            all_constraints_by_name[name] = callback

    # we'll need to resurse our way through the schema to check all the constraints
    # so we'll create a couple functions to help us navigate the way
    def check_primitiveConstraint(value_to_check: Any, defining_primitive: Definition):
        """Runs all the constraints for a given primitive."""

        # Check the value_to_check against the defining_primitive
        defining_primitive_instance: Primitive = defining_primitive.instance
        for constraint_assignment in defining_primitive_instance.constraints:
            constraint_name = constraint_assignment.name
            constraint_args = constraint_assignment.arguments
            callback = all_constraints_by_name[constraint_name]
            result: ExecutionResult = callback(value_to_check, constraint_args)
            constraint_results[constraint_name] = result

    def check_schema_constraint(instance_to_check: Any, defining_schema: Definition):
        """Runs all the constraints for a given schema."""

        # Check the instance_to_check against the defining_schema
        for constraint_assignment in instance_to_check.constraints:
            constraint_name = constraint_assignment.name
            constraint_args = constraint_assignment.arguments
            callback = all_constraints_by_name[constraint_name]
            result: ExecutionResult = callback(instance_to_check, constraint_args)
            constraint_results[constraint_name] = result

        # loop through the fields on the defining_schema
        for field in defining_schema.instance.fields:
            field_definining_schema = context.get_definition_by_name(field.type)
            if not field_definining_schema:
                raise LanguageError(f"Could not find schema for field: {field.name} of type: {field.type}")
            if field_definining_schema.get_root_key() == "primitive":
                # if the field is a primitive, run the primitive constraints
                check_primitiveConstraint(getattr(instance_to_check, field.name), field_definining_schema)
            else:
                # if the field is a schema, run the schema constraints
                check_schema_constraint(getattr(instance_to_check, field.name), field_definining_schema)
    
    # now that the helper functions are in place, let's run the constraints on the aac_file
    
    # TODO: Figure out if we have a chicken-and-egg problem here.  There is a possibility that the aac_file contains
    # definitions that have not been processed through gen-plugin, so there may be no instance field populated.
    # While this is theoretically possible, it should be unlikely.  Logically, the contents of the aac_file should be
    # items we handled manually in the early development of the POP API such as schema, plugin, primitive, etc.
    # As long as a user incrementally defines AaC extensions by first defining schemas, then generating code for the schemas,
    # before using their new schemas in other extension work, this should not be a problem.  We'll want some good documentation
    # on this use case for the AaC developer guide.
    definitions_to_check = context.parse_and_load(aac_file)

    # First run all context constraint checks
    # Context constraints are "language constraints" and are not tied to a specific schema
    # You can think of these as "invariants", so they must always be satisfied
    for definition in context.get_definitions_by_root("context_constraint"):
        callback = all_constraints_by_name[definition.name]
        result: ExecutionResult = callback()
        constraint_results[definition.name] = result

    for check_me in definitions_to_check:
        defining_schema = context.get_definitions_by_root(check_me.get_root_key())[0]
        constraint_results.update(check_schema_constraint(check_me, defining_schema))

    # loop through all the constraint results and see if any of them failed
    messages = []
    status = ExecutionStatus.SUCCESS
    for name, result in constraint_results.items():
        if result.is_success():
            # if the result is a success, add the messages to the list if we're in verbose mode
            # because these should only be info messages
            if verbose:
                messages.extend(result.messages)
        elif result.status_code == ExecutionStatus.CONSTRAINT_WARNING:
            # if the result is a warning, add the messages to the list and fail the check if fail_on_warn is true
            if fail_on_warn:
                status = result.status_code
            messages.extend(result.messages)
        else:
            # Any failure (including a constraint failure) is handled the same way
            status = result.status_code
            messages.extend(result.messages)

    return ExecutionResult(
        plugin_name, "check", status, messages
    )


