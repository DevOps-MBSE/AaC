"""The AaC CheckAaC plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

from typing import Callable, Any
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from aac.execute.aac_execution_result import ExecutionResult, ExecutionStatus, LanguageError, ExecutionMessage
from aac.lang.primitive import Primitive
from aac.lang.schema import Schema
from aac.lang.schemaconstraintassignment import SchemaConstraintAssignment
from aac.io.parser import parse

plugin_name = "CheckAaC"


def check(aac_file: str, fail_on_warn: bool, verbose: bool) -> ExecutionResult:
    """Business logic for the check command."""

    constraint_results: dict[str, ExecutionResult] = {}

    context: LanguageContext = LanguageContext()

    # collect all constraints for easy access
    all_constraints_by_name: dict[str, Callable] = {}
    for runner in context.get_plugin_runners():
        for name, callback in runner.constraint_to_callback.items():
            all_constraints_by_name[name] = callback

    # we'll need to resurse our way through the schema to check all the constraints
    # so we'll create a couple functions to help us navigate the way
    def check_primitiveConstraint(source_definition: Definition, value_to_check: Any, primitive_declaration: str, defining_primitive: Primitive):
        """Runs all the constraints for a given primitive."""

        # Check the value_to_check against the defining_primitive
        defining_primitive_instance: Primitive = defining_primitive
        for constraint_assignment in defining_primitive_instance.constraints:
            constraint_name = constraint_assignment.name
            constraint_args = constraint_assignment.arguments
            callback = all_constraints_by_name[constraint_name]
            # TODO: fix this location hack!
            result: ExecutionResult = callback(value_to_check, primitive_declaration, constraint_args, source_definition.source, None)
            constraint_results[constraint_name] = result

    def check_schema_constraint(source_definition: Definition, check_me: Any, check_against: Schema):
        """Runs all the constraints for a given schema."""
        # collact applicable constraints
        schema_constraints: list[SchemaConstraintAssignment] = []
        for runner in context.get_plugin_runners():
            plugin = runner.plugin_definition.instance
            for constraint in plugin.schema_constraints:
                if constraint.universal:
                    schema_constraints.append(SchemaConstraintAssignment(name=constraint.name, arguments=[]))

        if check_against.constraints:
            for constraint_assignment in check_against.constraints:
                schema_constraints.append(constraint_assignment)
        
        # Check the check_me against constraints in the defining_schema
        for constraint_assignment in schema_constraints:
            constraint_name = constraint_assignment.name
            constraint_args = constraint_assignment.arguments
            callback = all_constraints_by_name[constraint_name]
            result: ExecutionResult = callback(check_me, source_definition, check_against, constraint_args)
            constraint_results[constraint_name] = result

        # loop through the fields on the check_against schema
        for field in check_against.fields:
            # only check the field if it is present
            if not hasattr(check_me, field.name):
                continue

            # get the name of the schema that defines the field, special handling for arrays and references
            type_name = field.type
            is_list = False
            # if type name ends with "[]", remove the brackets and set is_list to True
            if field.type.endswith("[]"):
                type_name = field.type[:-2]
                is_list = True
            # if type name has parameters in perens, remove them
            if type_name.find("(") > -1:
                type_name = type_name[:type_name.find("(")]
            
            # get the definition that defines the field
            field_definining_schema = context.get_definition_by_name(type_name)

            if not field_definining_schema:
                raise LanguageError(f"Could not find schema for field: {field.name} of type: {field.type}")
            if field_definining_schema.get_root_key() == "primitive":
                # if the field is a primitive, run the primitive constraints
                if is_list:
                    # if the field is a list, check each item in the list
                    for item in getattr(check_me, field.name):
                        value_to_check = item
                        if value_to_check is not None:
                            check_primitiveConstraint(source_definition, item, field.type[:-2],field_definining_schema.instance)
                else:
                    value_to_check = getattr(check_me, field.name)
                    if value_to_check is not None:
                        check_primitiveConstraint(source_definition, getattr(check_me, field.name), field.type, field_definining_schema.instance)
            else:
                # if the field is a schema, run the schema constraints
                if is_list:
                    # if the field is a list, check each item in the list
                    for item in getattr(check_me, field.name):
                        check_schema_constraint(source_definition, item, field_definining_schema.instance)
                else:
                    check_schema_constraint(source_definition, getattr(check_me, field.name), field_definining_schema.instance)
    
    # now that the helper functions are in place, let's run the constraints on the aac_file
    definitions_to_check = context.parse_and_load(aac_file)

    # First run all context constraint checks
    # Context constraints are "language constraints" and are not tied to a specific schema
    # You can think of these as "invariants", so they must always be satisfied
    for plugin in context.get_definitions_by_root("plugin"):
        for context_constraint in plugin.instance.context_constraints:
            callback = all_constraints_by_name[context_constraint.name]
            result: ExecutionResult = callback(context)
            constraint_results[context_constraint.name] = result

    for check_me in definitions_to_check:
        defining_schema = context.get_defining_schema_for_root(check_me.get_root_key())
        check_schema_constraint(check_me, check_me.instance, defining_schema.instance)

    # loop through all the constraint results and see if any of them failed
    messages = []
    status = ExecutionStatus.SUCCESS
    for name, result in constraint_results.items():
        if result.is_success():
            # if the result is a success, add the messages to the list if we're in verbose mode
            # because these should only be info messages
            if verbose:
                messages.extend(result.messages)
        elif result.status_code == ExecutionStatus.CONSTRAINT_WARNING:
            # if the result is a warning, add the messages to the list and fail the check if fail_on_warn is true
            if fail_on_warn:
                status = result.status_code
            messages.extend(result.messages)
        else:
            # Any failure (including a constraint failure) is handled the same way
            status = result.status_code
            messages.extend(result.messages)

    # after goign through all the constraint results, if we're still success add a success message
    if status == ExecutionStatus.SUCCESS:
        happy_msg = ExecutionMessage(message="All AaC constraint checks were successful.", source=None, location=None)
        messages.append(happy_msg)

    return ExecutionResult(
        plugin_name, "check", status, messages
    )


