"""AaC Plugin implementation module for the aac-gen-protobuf plugin."""

# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

import logging

from aac.lang.definitions.definition import Definition
from aac.lang.definitions.arrays import is_array_type
from aac.lang.definition_helpers import get_definitions_by_root_key
from aac.lang.definitions.search import search_definition
from aac.lang.active_context_lifecycle_manager import get_active_context
from aac.plugins import PluginError
from aac.plugins.plugin_execution import (
    PluginExecutionResult,
    plugin_result,
)
from aac.template_engine import (
    TemplateOutputFile,
    generate_template,
    load_default_templates,
    write_generated_templates_to_file,
)
from aac.validate import validated_source

plugin_name = "gen-protobuf"

ACTIVE_CONTEXT = get_active_context()


def gen_protobuf(architecture_file: str, output_directory: str) -> PluginExecutionResult:
    """
    Gen-protobuf plugin command entry point. Generate protobuf messages from Arch-as-Code models.

    Args:
        architecture_file (str): The yaml file containing the data models to generate as Protobuf messages.
        output_directory (str): The directory to write the generated Protobuf messages to.
    """

    # Run our primary function, generate_protobuf, inside the plugin_result context manager
    with plugin_result(plugin_name, generate_protobuf_messages, architecture_file, output_directory) as result:
        return result


def generate_protobuf_messages(architecture_file: str, output_directory: str) -> None:
    """
    Generate protobuf messages from Arch-as-Code model interfaces.

    Args:
        architecture_file (str): The yaml file containing the data models to generate as Protobuf messages.
        output_directory (str): The directory to write the generated Protobuf messages to.
    """

    # Validate the source AaC file and its contents
    with validated_source(architecture_file) as validation_result:
        loaded_templates = load_default_templates("gen_protobuf")

        validated_definitions = validation_result.definitions
        model_definitions = get_definitions_by_root_key("model", validated_definitions)

        model_interface_messages = _get_model_interface_data_structures(model_definitions)
        message_template_properties = _collect_template_generation_properties(model_interface_messages)

        generated_template_messages = _generate_protobuf_messages(loaded_templates, message_template_properties)

        write_generated_templates_to_file(generated_template_messages, output_directory)

        return f"Successfully generated templates to directory: {output_directory}"


def _get_model_interface_data_structures(model_definitions: list[Definition]) -> dict[str, Definition]:
    """
    Collect all data and enum definitions that are referenced as interface messages or as a nested type within an interface message.

    Args:
        model_definitions: A list of model definitions to parse for interface messages

    Returns:
        A dict of data message type keys to data message parsed model values
    """
    interface_message_types = set()
    for model in model_definitions:
        model_behavior_keys = ["model", "behavior"]

        model_interface_messages = []
        model_interface_messages += search_definition(model, model_behavior_keys + ["input"])
        model_interface_messages += search_definition(model, model_behavior_keys + ["output"])

        interface_message_types.update([message.get("type") for message in model_interface_messages])

    # For each interface message type, get the list of AaC structures that compose those messages
    interface_message_substructure_types = set()
    for interface_message_type in interface_message_types:
        interface_message_type_definition = ACTIVE_CONTEXT.get_definition_by_name(interface_message_type)

        if interface_message_type_definition:
            interface_message_substructure_names = [field.get("type") for field in interface_message_type_definition.get_fields().get("fields")]
            interface_message_substructure_types.update(interface_message_substructure_names)
        else:
            logging.error(f"Failed to find definition for type '{interface_message_type}'")

    interface_message_types.update(interface_message_substructure_types)
    definition_messages_types = list(filter(lambda name: not ACTIVE_CONTEXT.is_primitive_type(name), interface_message_types))

    return {data_message_type: ACTIVE_CONTEXT.get_definition_by_name(data_message_type) for data_message_type in definition_messages_types}


def _collect_template_generation_properties(interface_structures: dict[str, Definition]) -> list[dict]:
    """
    Analyzes data and enum models and produces a list of template property dictionaries for each protobuf file to generate.

    Args:
        data_and_enum_models: a dict of models where the key is the model name and the value is the model dict. Each model represents a protobuf message.

    Returns:
        a list of template property dicts
    """

    template_properties_list = []
    for def_name, definition in interface_structures.items():

        if not definition:
            logging.error(f"This dude -> '{def_name}'")

        if definition.is_enum():
            template_properties_list.append(_get_enum_properties(definition))

        else:
            template_properties_list.append(_get_data_model_properties(interface_structures, definition))

    return template_properties_list


def _properties_dict(
    name: str, definition_type: str, enums: list[str] = [], fields: list[dict] = [], imports: list[str] = []
) -> dict[str, any]:
    """
    Provides a consistent dictionary structure for model properties.

    Args:
        name (str): The name of the model/enum
        definition_type (str): The definition type
        enums (list): A list of enum values
        fields (list): A list of model fields
        imports (list): A list of model imports

    Returns:
        A dictionary containing the properties in a consistent structure.
    """

    properties = {
        "name": name,
        "file_type": definition_type,
    }

    if enums:
        properties["enums"] = enums
    if fields:
        properties["fields"] = fields
    if imports:
        properties["imports"] = imports

    return properties


def _get_enum_properties(enum_definition: Definition) -> dict[str, any]:
    """
    Analyzes an enum definition and returns a properties dictionary for template generation.

    Args:
        enum_definition (dict): An enum defintion as a dictionary

    Returns:
         A dictionary containing the template generation properties.
    """
    enum_values = [enum.upper() for enum in enum_definition.get_fields().get("values")]
    return _properties_dict(enum_definition.name, "enum", enums=enum_values)


def _get_data_model_properties(interface_structures: dict[str, Definition], data_definition: Definition) -> dict[str, any]:
    """
    Analyzes a data model definition and returns a properties dictionary for template generation.

    Args:
        data_and_enum_models (dict): A list of data model and enum defintions for enum/data model reference lookup
        data_model (dict): A data model defintion as a dictionary

    Returns:
         A dictionary containing the template generation properties.
    """
    definition_fields = data_definition.get_fields()
    required_fields = definition_fields.get("required") or []
    structure_fields = definition_fields.get("fields")

    message_fields = []
    message_imports = []
    for field in structure_fields:
        proto_field_name = field.get("name")
        proto_field_type = None

        field_type = field.get("type")
        field_proto_type = field.get("protobuf_type")
        if field_type in interface_structures:
            proto_field_type = field_type

            # This is the last time we have access to the other model, calculate its future protobuf file name here
            model_to_import = interface_structures.get(field_type)
            message_imports.append(_convert_message_name_to_file_name(model_to_import.name))

        else:
            # If the referenced type isn't a user-defined type, then set the primitive type prioritizing `protobuf_type` before `type`
            proto_field_type = field_proto_type or field_type

        message_fields.append(
            {
                "name": proto_field_name,
                "type": proto_field_type,
                "optional": proto_field_name not in required_fields,
                "repeat": is_array_type(field_type),
            }
        )

    return _properties_dict(data_definition.name, "data", fields=message_fields, imports=message_imports)


def _generate_protobuf_messages(protobuf_message_templates: list, properties: list[dict]) -> list[TemplateOutputFile]:
    """
    Compile templates and with variable properties information.

    File and general structure style will follow the google protobuf style which can be found at
        https://developers.google.com/protocol-buffers/docs/style

    Args:
        protobuf_message_templates: templates to generate against. (Should only be one template)
        properties: a list of dicts of properties

    Returns:
        list of template information dictionaries.
    """

    def generate_protobuf_message_from_template(properties) -> TemplateOutputFile:
        generated_template = generate_template(protobuf_template, properties)
        generated_template.file_name = _convert_message_name_to_file_name(properties.get("name"))
        generated_template.overwrite = True  # Protobuf files shouldn't be modified by the user, and so should always overwrite
        return generated_template

    # This plugin produces only protobuf messages and one message per file due to protobuf specifications. (it only needs one template)
    protobuf_template = None
    if len(protobuf_message_templates) != 1:
        raise GenerateProtobufException(
            f"Unexpected number of templates loaded {len(protobuf_message_templates)}, "
            f"expecting only protobuf message template.\nLoaded templates: {protobuf_message_templates}"
        )
    else:
        protobuf_template = protobuf_message_templates[0]

    return list(map(generate_protobuf_message_from_template, properties))


def _convert_message_name_to_file_name(message_name: str) -> str:
    """
    Convert a `data:` definition's name into an opinionated and stylized protobuf 3 file name.

    File and general structure style will follow the google protobuf style which can be found at
        https://developers.google.com/protocol-buffers/docs/style

    Args:
        message_name: the name of a `data:` definition to convert to a protobuf file name

    Returns:
        A protobuf file name string
    """
    new_file_name = f"{message_name}.proto"
    new_file_name = new_file_name.replace("- ", "_")
    new_file_name = _convert_camel_case_to_snake_case(new_file_name)
    return new_file_name


def _convert_camel_case_to_snake_case(camel_case_str: str) -> str:
    """
    Convert a camelCase string to a snake_case string.

    Args:
        camel_case_str: the camelCase string to convert

    Returns:
        a snake_case string
    """
    snake_case_str = camel_case_str[:1].lower()
    for char in camel_case_str[1:]:
        snake_case_str += (char, f"_{char.lower()}")[char.isupper()]
    return snake_case_str


class GenerateProtobufException(PluginError):
    """Exceptions specifically concerning protobuf message generation."""

    pass
