"""The AaC Required Fields plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

from aac.execute.aac_execution_result import ExecutionResult, ExecutionStatus, LanguageError, ExecutionMessage
from aac.lang.plugininputvalue import PluginInputValue
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from typing import Any


plugin_name = "Required Fields"


def required_fields_are_present(
    instance: Any, source_definition: Definition, defining_schema: Definition, arguments: list[PluginInputValue]
) -> ExecutionResult:
    """Business logic for the Required fields are present constraint."""

    status = ExecutionStatus.SUCCESS
    messages: list[ExecutionMessage] = []

    context = LanguageContext()

    # we'll need to resurse our way through the schema to check all the fields and sub-fields
    def check_schema_fields(instance_to_check: Any, source_definition: Definition, defining_schema: Definition):
        """Check that all required fields are present in the instance_to_check based on the defining_schema."""

        # Loop through all fields in the definiing schema
        for field in defining_schema.instance.fields:
            # If the field is required, check that it is present
            if field.is_required:
                # Check that the field is present
                if field.name not in list(vars(instance_to_check).keys()):
                    status = ExecutionStatus.CONSTRAINT_FAILURE
                    # TODO:  clean up this location hack!
                    error_msg = ExecutionMessage(message=f"Field '{field.name}' is required but not present.", source=source_definition.source, location=None)
                    messages.append(error_msg)
            
            # TODO:  do we want to recurse sub-fields here or in the check command?
            # now recurse into any nested schemas
            # type_name = field.type
            # is_list = False
            # # if type name ends with "[]", remove the brackets and set is_list to True
            # if field.type.endswith("[]"):
            #     type_name = field.type[:-2]
            #     is_list = True
            # # if type name has parameters in perens, remove them
            # if type_name.find("(") > -1:
            #     type_name = type_name[:type_name.find("(")]
            
            # if type_name not in [primitive.name for primitive in context.get_primitives()]:
            #     # we have a schema, so we'll recurse and check it's fields
            #     field_defining_schema = context.get_definition_by_name(type_name)
            #     if not field_defining_schema:
            #         raise LanguageError(f"Could not find schema for field: {field.name} of type: {field.type}")
            #     if is_list:
            #         field_instance_list = getattr(instance_to_check, field.name)
            #         for field_instance in field_instance_list:
            #             check_schema_fields(field_instance, field_defining_schema)
            #     else:
            #         field_instance = getattr(instance_to_check, field.name)
            #         if field_instance:  # not all fields are required, so only check if the field is present
            #             check_schema_fields(field_instance, field_defining_schema)

    # check against the defining schema
    # check_schema_fields(instance, defining_schema)
    # Loop through all fields in the definiing schema
    for field in defining_schema.instance.fields:
        # If the field is required, check that it is present
        if field.is_required:
            # Check that the field is present
            if field.name not in list(vars(instance).keys()):
                status = ExecutionStatus.CONSTRAINT_FAILURE
                # TODO:  clean up this location hack!
                error_msg = ExecutionMessage(message=f"Field '{field.name}' is required but not present.", source=source_definition.source, location=None)
                messages.append(error_msg)

    return ExecutionResult(plugin_name, "Required fields are present", status, messages)
