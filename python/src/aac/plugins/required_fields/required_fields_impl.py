"""The AaC Required Fields plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

from aac.execute.aac_execution_result import ExecutionResult, ExecutionStatus, ExecutionMessage
# from aac.lang.schema import Schema
# from aac.lang.plugininputvalue import PluginInputValue
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from typing import Any


plugin_name = "Required Fields"


def required_fields_are_present(
    instance: Any, definition: Definition, defining_schema
) -> ExecutionResult:
    """Business logic for the Required fields are present constraint."""

    status = ExecutionStatus.SUCCESS
    messages: list[ExecutionMessage] = []

    # check will send in every possible thing, even None, so we need to check that we have an instance
    if instance:
        context = LanguageContext()

        # Note:  We only need to check the provided instance.  The check command handles field recursion for us.
        # Loop through all fields in the definiing schema
        for field in defining_schema.fields:
            # If the field is required, check that it is present
            if field.is_required:
                # Check that the field is present
                if not hasattr(instance, field.name):
                    status = ExecutionStatus.CONSTRAINT_FAILURE
                    # TODO:  clean up this location hack!
                    error_msg = ExecutionMessage(message=f"Field '{field.name}' is required but not present.", source=definition.source, location=None)
                    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Required fields are present", status, messages)
