"""AaC Plugin implementation module for the aac-spec plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from aac import parser, util
from aac.validator import validation


def spec_validate(architecture_file: str):
    """
    Validates spec traces within the AaC model.  If the model is invalid, print errors and exit with a code of 1.

    Args:
        architecture_file (str): The file to validate for spec cross-references.
    """

    is_valid, validation_errors = _run_full_validation(architecture_file)

    # if validation errors have been found raise a validation exception
    if not is_valid:
        print("Spec is invalid")
        raise AacSpecValidationException("Spec is invalid:\n" + "\n".join(validation_errors))
    else:
        print("Spec is valid.")


def _run_full_validation(architecture_file: str) -> tuple[bool, list]:
    with validation(parser.parse_file, architecture_file) as parsed_model:
        return _run_spec_validation(parsed_model)


def _run_spec_validation(parsed_model: dict):
    is_valid = True
    validation_errors = []

    # go through the parsed model to find requirement references
    req_refs = {}
    for model_name in parsed_model:
        refs = []
        refs.extend(util.search(parsed_model[model_name], ["spec", "requirements", "parent"]))
        refs.extend(util.search(parsed_model[model_name], ["model", "behavior", "requirements"]))
        refs.extend(util.search(parsed_model[model_name], ["data", "requirements"]))
        if refs:
            req_refs[model_name] = refs

    # get all the specs by abbreviation
    spec_by_abbrv = {}

    specs = util.get_models_by_type(parsed_model, "spec")
    # for spec_name in specs:

    # ensure all req_refs are present in the referenced location
    for model_name in req_refs:
        for ref in req_refs[model_name]:
            abbrv = ref["abbreviation"]
            if abbrv in spec_by_abbrv:
                # abbrv ref is good, now check the ids
                ids_in_spec = []
                ids_in_spec.extend(
                    util.search(spec_by_abbrv[abbrv], ["spec", "requirements", "id"])
                )
                ids_in_spec.extend(
                    util.search(spec_by_abbrv[abbrv], ["spec", "sections", "requirements", "id"])
                )

                ids = ref["ids"]
                # ids could be a list of values or a single value, so check both possibilities
                if isinstance(ids, list):
                    for id in ids:
                        if id not in ids_in_spec:
                            is_valid = False
                            validation_errors.append(
                                f"Invalid requirement id {id} reference in {model_name}: {ref}"
                            )
                else:
                    if ids not in ids_in_spec:
                        is_valid = False
                        validation_errors.append(
                            f"Invalid requirement id {ids} reference in {model_name}: {ref}"
                        )

            else:
                is_valid = False
                validation_errors.append(
                    f"Invalid requirement abbreviation {abbrv} reference in {model_name}:  {ref}"
                )

    return is_valid, validation_errors


class AacSpecValidationException(Exception):
    """Exceptions specifically concerning errors when validating specs."""

    pass
