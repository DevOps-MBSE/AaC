"""AaC Plugin implementation module for the aac-spec plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from attr import attrs, attrib
from aac import parser, util
from aac.validator import validation


def spec_validate(architecture_file: str):
    """
    Validates spec traces within the AaC model.  If the model is invalid, print errors and exit with a code of 1.

    Args:
        architecture_file (str): The file to validate for spec cross-references.
    """

    is_valid, validation_errors = _run_full_validation(architecture_file)

    # if validation errors have been found raise a validation exception
    if not is_valid:
        print("Spec is invalid")
        raise AacSpecValidationException("Spec is invalid:\n" + "\n".join(validation_errors))
    else:
        print("Spec is valid.")


def _run_full_validation(architecture_file: str) -> tuple[bool, list]:
    with validation(parser.parse_file, architecture_file) as parsed_model:
        return _run_spec_validation(parsed_model)


def _run_spec_validation(parsed_model: dict):  # noqa: C901
    is_valid = True
    validation_errors = []

    # go through the parsed model to find requirement references
    requirement_refs = {}
    for model_name in parsed_model:
        refs = []
        refs.extend(
            util.search(parsed_model[model_name], ["spec", "requirements", "parent", "ids"])
        )
        refs.extend(
            util.search(parsed_model[model_name], ["model", "behavior", "requirements", "ids"])
        )
        refs.extend(util.search(parsed_model[model_name], ["data", "requirements", "ids"]))
        if refs:
            requirement_refs[model_name] = refs

    specs = util.get_models_by_type(parsed_model, "spec")
    requirements_by_id = _collect_ids_from_specs(specs)

    # ensure all req_refs are present in the referenced location
    for model_name, id_references in requirement_refs.items():

        # Check the refs exists
        defined_requirement_ids = list(requirements_by_id.keys())
        for requirement_id in id_references:
            if requirement_id not in defined_requirement_ids:
                is_valid = False
                validation_errors.append(
                    f"Invalid requirement id '{requirement_id}' reference in '{model_name}':  {defined_requirement_ids}"
                )

    return is_valid, validation_errors


def _collect_ids_from_specs(specs: list[dict]) -> dict:
    """Returns all ids and their definitions as a key-value pair with the id being the key."""
    requirements_by_id = {}

    for spec in specs.values():
        spec_definition = spec.get("spec")
        spec_requirements = spec_definition.get("requirements") or []
        spec_sections = spec_definition.get("sections") or []

        for requirement in spec_requirements:
            requirements_by_id[requirement.get("id")] = requirement

        for section in spec_sections:
            section_requirements = section.get("requirements")

            for section_requirement in section_requirements:
                requirements_by_id[section_requirement.get("id")] = section_requirement

    return requirements_by_id


@attrs
class AacSpecValidationException(Exception):
    """Exceptions specifically concerning errors when validating specs."""

    message = attrib()
