"""AaC Plugin implementation module for the aac-spec plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from aac import util, parser

plugin_version = "0.0.1"


def spec_validate(architecture_file: str):
    """
    Validates spec traces within the AaC model.  If the model is invalid, print errors and exit with a code of 1.

    Args:
        architecture_file (str): The file to validate for spec cross-references.
    """

    is_valid, validation_errors = _do_validate(architecture_file)

    # if validation errors have been found raise a validation exception
    if not is_valid:
        print("Spec is invalid")
        raise AacSpecValidationException("Spec is invalid:\n" + "\n".join(validation_errors))
    else:
        print("Spec is valid.")


def _do_validate(architecture_file: str) -> tuple[bool, list]:

    is_valid = True
    validation_errors = []

    parsed_model = parser.parse_file(architecture_file)

    # go through the parsed model to find requirement references
    req_refs = {}
    for model_name in parsed_model:
        refs = []
        refs.extend(util.search(parsed_model[model_name], ["spec", "requirements", "parent"]))
        refs.extend(util.search(parsed_model[model_name], ["model", "behavior", "requirements"]))
        refs.extend(util.search(parsed_model[model_name], ["data", "requirements"]))
        if refs:
            req_refs[model_name] = refs

    # get all the specs by abbreviation
    spec_by_abbrv = {}

    specs = util.get_models_by_type(parsed_model, "spec")
    for spec_name in specs:

        abbrv = util.search(specs[spec_name], ["spec", "abbreviation"])
        if len(abbrv) == 1:
            spec_by_abbrv[abbrv[0]] = specs[spec_name]
        else:
            is_valid = False
            validation_errors.append(f"Spec named {spec_name} must have 1 abbrv in it's definition.  Found {abbrv}.")

    # ensure all req_refs are present in the referenced location
    for model_name in req_refs:
        for ref in req_refs[model_name]:
            abbrv = ref["abbreviation"]
            if abbrv in spec_by_abbrv:
                # abbrv ref is good, now check the ids
                ids_in_spec = []
                ids_in_spec.extend(util.search(spec_by_abbrv[abbrv], ["spec", "requirements", "id"]))
                ids_in_spec.extend(util.search(spec_by_abbrv[abbrv], ["spec", "sections", "requirements", "id"]))

                ids = ref["ids"]
                # ids could be a list of values or a single value, so check both possibilities
                if isinstance(ids, list):
                    for id in ids:
                        if id not in ids_in_spec:
                            is_valid = False
                            validation_errors.append(f"Invalid requirement id {id} reference in {model_name}: {ref}")
                else:
                    if ids not in ids_in_spec:
                        is_valid = False
                        validation_errors.append(f"Invalid requirement id {ids} reference in {model_name}: {ref}")

            else:
                is_valid = False
                validation_errors.append(f"Invalid requirement abbreviation {abbrv} reference in {model_name}:  {ref}")

    return is_valid, validation_errors


class AacSpecValidationException(Exception):
    """Exceptions specifically concerning errors when validating specs."""

    pass
